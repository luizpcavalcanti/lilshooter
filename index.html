<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AI-updated Arena — All features</title>
<style>
  html,body{height:100%;margin:0;background:#111;font-family:Verdana, sans-serif;color:#ddd}
  #wrap{height:100%;display:flex;align-items:center;justify-content:center}
  canvas{border:0.5rem outset pink;background:#222;display:block}
  #hud { position: absolute; top: 12px; left: 12px; color:#fff; font-size:13px; }
  #menuOverlay, #gameOverOverlay {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.6); color:#fff; flex-direction:column; gap:10px;
  }
  button{padding:8px 12px; font-size:14px; cursor:pointer}
  .small{font-size:12px;color:#bbb}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="ctx" width="900" height="800"></canvas>
  <div id="hud"></div>
  <div id="menuOverlay">
    <h2>Arena</h2>
    <div class="small">WASD mover • Clique atirar • Botão direito special</div>
    <button id="btnStart">Start Run</button>
    <div class="small">Features: abilities, mutations, enemy variants, bosses, telegraphs, hit indicators</div>
  </div>
  <div id="gameOverOverlay" style="display:none">
    <h2>GAME OVER</h2>
    <div id="goStats"></div>
    <button id="btnRestart">Restart</button>
  </div>
</div>

<!-- Audio (keep files in ./sounds/) -->
<audio id="shoot" src="./sounds/shoot.wav"></audio>
<audio id="bigshoot" src="./sounds/bigshoot.wav"></audio>
<audio id="supershoot" src="./sounds/supershoot.wav"></audio>
<audio id="powerup" src="./sounds/powerup.wav"></audio>
<audio id="coin" src="./sounds/coin.wav"></audio>
<audio id="hit" src="./sounds/hit.wav"></audio>

<script>
/* ===========================
   FULL ONE-FILE GAME
   Direct, no sugar.
   ===========================*/

/* ----------------- CONFIG ----------------- */
const canvas = document.getElementById('ctx');
const ctx = canvas.getContext('2d');
const HUD = document.getElementById('hud');
const menu = document.getElementById('menuOverlay');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const goStats = document.getElementById('goStats');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');

const WIDTH = canvas.width, HEIGHT = canvas.height;

/* audio */
const S = {
  shoot: document.getElementById('shoot'),
  bigshoot: document.getElementById('bigshoot'),
  supershoot: document.getElementById('supershoot'),
  powerup: document.getElementById('powerup'),
  coin: document.getElementById('coin'),
  hit: document.getElementById('hit'),
};

function safePlay(a){
  try{ a.currentTime = 0; a.play(); }catch(e){}
}

/* ----------------- STATE ----------------- */
let state = 'menu'; // menu | running | gameover
let player, enemies, bullets, upgrades, floatingText, mutations;
let lastTs = 0;
let score = 0;
let spawnAcc = 0;
let frames = 0;
let timeStarted = 0;

/* gameplay stats */
let stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };

/* screen effects */
let shake = 0;
let slowTimer = 0;
let killStreak = 0;
let slowFactor = 1.0;

/* boss control */
let killsSinceBoss = 0;
const KILLS_FOR_BOSS = 15;

/* ability pool (unchanged) */
const ABILITY_POOL = ["DoubleShoot","DoubleDamage","BurstSpawn","SpecialMod","WideSpread"];

/* mutations pool */
const MUTATIONS_POOL = [
  {id:'bounce', name:'Bounce Bullets', desc:'bullets bounce once'},
  {id:'pierce', name:'Pierce Bullets', desc:'bullets pierce one enemy'},
  {id:'explode', name:'Explode On Death', desc:'enemies explode on death'},
  {id:'lowhpfast', name:'LowHP Speed', desc:'player faster when low HP'},
  {id:'trail', name:'Burn Trail', desc:'bullets leave damaging trail'}
];

/* ----------------- HELPERS ----------------- */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function now(){ return performance.now(); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function rectCol(a,b){ return a.x - a.width/2 < b.x + b.width/2 && a.x + a.width/2 > b.x - b.width/2 && a.y - a.height/2 < b.y + b.height/2 && a.y + a.height/2 > b.y - b.height/2; }

/* ----------------- ENTITIES ----------------- */
function spawnPlayer(){
  player = {
    type:'player', x: WIDTH/2, y: HEIGHT/2, width:22, height:22,
    hp:10, color:'LightGreen', AimAngle:0,
    atkSpeed:1, atkCounter:0,
    pressing:{up:false,down:false,left:false,right:false},
    abilities:[], // names shown on HUD
    // flags
    doubleShoot:false, doubleDamage:false, burstSpawn:false, specialCooldownModifier:1, wideSpread:false
  };
}

function spawnEnemyVariant(kind){
  const id = Math.random();
  const base = { type:'enemy', id, x:rand(0,WIDTH), y:rand(0,HEIGHT), width:rand(12,30), height:rand(12,30), color:'Maroon', vx:0, vy:0, life:1, variant:'normal', telegraph:0 };
  if (!kind) {
    // choose variant by probability
    const r = Math.random();
    if (r < 0.15) kind = 'tank';
    else if (r < 0.35) kind = 'fast';
    else if (r < 0.55) kind = 'ranged';
    else if (r < 0.7) kind = 'splitter';
    else kind = 'normal';
  }
  base.variant = kind;
  if (kind === 'fast'){ base.vx = rand(-80,80); base.vy = rand(-80,80); base.life = 1; base.color='orangered'; }
  else if (kind === 'tank'){ base.vx = rand(-20,20); base.vy = rand(-20,20); base.life = 4; base.color='darkred'; base.width*=1.6; base.height*=1.6;}
  else if (kind === 'ranged'){ base.vx = rand(-30,30); base.vy = rand(-30,30); base.life = 2; base.color='purple'; base.telegraph = 0; }
  else if (kind === 'splitter'){ base.vx=rand(-40,40); base.vy=rand(-40,40); base.life=2; base.color='sienna'; }
  else { base.vx = rand(-40,40); base.vy = rand(-40,40); base.life = 1; }
  enemies[id]=base;
}

function spawnUpgrade(){
  const id = Math.random();
  const r = Math.random();
  let cat = 'ability', color='deepskyblue';
  if (r < 0.33) { cat='low'; color='khaki'; }
  else if (r < 0.66) { cat='atkSpeed'; color='blueviolet'; }
  // else ability
  upgrades[id] = { type:'upgrade', id, x:rand(30,WIDTH-30), y:rand(30,HEIGHT-30), width:13, height:13, category:cat, color };
}

function spawnBullet(owner, angleDeg, props = {}){
  const id = Math.random();
  const speed = props.speed || 650;
  const damage = props.damage ?? (owner === 'player' ? (player.doubleDamage?8:4) : 3);
  bullets[id] = {
    id, type:'bullet', x:owner.x, y:owner.y, width:6, height:6,
    xs: Math.cos(angleDeg*Math.PI/180)*speed, ys: Math.sin(angleDeg*Math.PI/180)*speed,
    timer:0, damage, ownerTag: owner === player ? 'player' : 'enemy', bounces: props.bounces || 0, pierced: 0
  };
}

/* ----------------- VISUALS / FX ----------------- */
floatingText = []; // {x,y,txt,ttl,vy}
function addFloatingText(x,y,txt,color='white',ttl=1000){
  floatingText.push({x,y,txt,color,ttl,created:now(),vy:-0.03});
}

function drawFloating(dt){
  const nowt = now();
  for (let i=floatingText.length-1;i>=0;i--){
    const f = floatingText[i];
    const age = nowt - f.created;
    if (age > f.ttl) { floatingText.splice(i,1); continue; }
    ctx.save();
    ctx.globalAlpha = clamp(1 - age/f.ttl,0,1);
    ctx.fillStyle = f.color;
    ctx.font = '14px Verdana';
    ctx.fillText(f.txt, f.x, f.y + (age/20));
    ctx.restore();
  }
}

/* ----------------- MUTATIONS ----------------- */
mutations = [];
function grantRandomMutation(){
  // pick one not already present if possible
  const candidates = MUTATIONS_POOL.filter(m => !mutations.find(x=>x.id===m.id));
  const pick = candidates.length ? candidates[Math.floor(Math.random()*candidates.length)] : MUTATIONS_POOL[Math.floor(Math.random()*MUTATIONS_POOL.length)];
  mutations.push(pick);
  addFloatingText(player.x, player.y - 30, 'MUTATION: ' + pick.name, 'cyan', 1500);
}

/* ----------------- INPUT ----------------- */
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  player.AimAngle = Math.atan2(my - player.y, mx - player.x) * 180 / Math.PI;
});
canvas.addEventListener('click', ()=>{
  if (state !== 'running') return;
  if (player.atkCounter > 50){
    // shots depend on abilities
    safePlay(S.shoot);
    player.atkCounter -= 25;
    stats.shots++;
    if (player.wideSpread){
      spawnBullet(player, player.AimAngle - 10);
      spawnBullet(player, player.AimAngle);
      spawnBullet(player, player.AimAngle + 10);
    } else if (player.doubleShoot){
      spawnBullet(player, player.AimAngle - 5);
      spawnBullet(player, player.AimAngle + 5);
    } else {
      spawnBullet(player, player.AimAngle);
    }
  }
});

canvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
  if (state !== 'running') return;
  const req = 500 * (player.specialCooldownModifier || 1);
  if (player.atkCounter > req){
    safePlay(S.supershoot);
    for (let a=0;a<360;a+=9) spawnBullet(player, a);
    player.atkCounter = 0;
    shake = 10;
    addFloatingText(player.x, player.y-20, 'SPECIAL!', 'yellow', 1200);
    return;
  }
  if (player.atkCounter > 50){
    safePlay(S.bigshoot);
    player.atkCounter -= 50;
    spawnBullet(player, player.AimAngle + 15);
    spawnBullet(player, player.AimAngle + 5);
    spawnBullet(player, player.AimAngle);
    spawnBullet(player, player.AimAngle - 5);
    spawnBullet(player, player.AimAngle - 15);
  }
});

document.addEventListener('keydown', e=>{
  if (!player) return;
  if (e.key==='w' || e.key==='W') player.pressing.up = true;
  if (e.key==='s' || e.key==='S') player.pressing.down = true;
  if (e.key==='a' || e.key==='A') player.pressing.left = true;
  if (e.key==='d' || e.key==='D') player.pressing.right = true;
});
document.addEventListener('keyup', e=>{
  if (!player) return;
  if (e.key==='w' || e.key==='W') player.pressing.up = false;
  if (e.key==='s' || e.key==='S') player.pressing.down = false;
  if (e.key==='a' || e.key==='A') player.pressing.left = false;
  if (e.key==='d' || e.key==='D') player.pressing.right = false;
});

/* ----------------- SPAWN LOGIC ----------------- */
function spawnTick(dt){
  spawnAcc += dt;
  const baseInterval = 2.5;
  const interval = baseInterval * Math.max(0.5, 1 - (score/20000)); // speed up with score
  while (spawnAcc > interval){
    spawnAcc -= interval;
    // spawn variants
    if (Math.random() < 0.05) { spawnEnemyVariant('ranged'); }
    else if (Math.random() < 0.12) { spawnEnemyVariant('fast'); }
    else if (Math.random() < 0.18) { spawnEnemyVariant('splitter'); }
    else if (Math.random() < 0.25) { spawnEnemyVariant('tank'); }
    else spawnEnemyVariant('normal');
  }

  // occasional upgrade spawn
  if (Math.random() < 0.01) spawnUpgrade();

  // occasional mutation drop (rare)
  if (Math.random() < 0.002) grantRandomMutation();
}

/* ----------------- ENEMY BEHAVIOUR ----------------- */
function updateEnemies(dt){
  for (const id in enemies){
    const e = enemies[id];
    // ranged telegraphing: charges telegraph before shooting every few seconds
    if (e.variant === 'ranged'){
      e.telegraph = (e.telegraph || 0) - dt;
      if (e.telegraph <= 0){
        e.telegraph = 2 + Math.random()*2; // next telegraph in 2-4s
        e._teleCount = 0;
      }
      // when telegraph near 0, flash and shoot
      if (e.telegraph > 1.6){
        // idle, move slowly
        e.x += e.vx * dt * 0.6; e.y += e.vy * dt * 0.6;
      } else if (e.telegraph > 0.5){
        // telegraph flash (we'll draw it later)
        // small approach
        const ang = Math.atan2(player.y - e.y, player.x - e.x);
        e.x += Math.cos(ang) * 20 * dt;
        e.y += Math.sin(ang) * 20 * dt;
      } else {
        // shoot burst once
        if (!e._didShoot){
          // shoot towards player
          const angDeg = Math.atan2(player.y - e.y, player.x - e.x) * 180/Math.PI;
          spawnBullet(e, angDeg, {speed:400, damage:3});
          e._didShoot = true;
          // slight push
          e.x += rand(-10,10); e.y += rand(-10,10);
        }
        // let telegraph expire
      }
    } else {
      // general movement: simple wandering towards player
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      let speed = 40;
      if (e.variant === 'fast') speed = 150;
      if (e.variant === 'tank') speed = 30;
      e.x += Math.cos(angle) * speed * dt;
      e.y += Math.sin(angle) * speed * dt;
    }

    // boundary clamp
    e.x = clamp(e.x, e.width/2, WIDTH - e.width/2);
    e.y = clamp(e.y, e.height/2, HEIGHT - e.height/2);
  }
}

/* ----------------- BULLETS ----------------- */
function updateBullets(dt){
  for (const id in bullets){
    const b = bullets[id];
    b.timer += dt;
    // movement
    b.x += b.xs * dt;
    b.y += b.ys * dt;

    // trail mutation
    if (mutations.find(m=>m.id==='trail')){
      // occasionally spawn damage tick (visual only)
      if (Math.random() < 0.01) addFloatingText(b.x, b.y, '.', 'orange', 300);
    }

    // boundary bounce if mutation bounce
    if (mutations.find(m=>m.id==='bounce') && (b.x < 0 || b.x > WIDTH || b.y < 0 || b.y > HEIGHT)){
      if (b.bounces > 0){
        // reflect and reduce bounces
        b.xs *= -1; b.ys *= -1; b.bounces--;
      } else {
        delete bullets[id]; continue;
      }
    }

    if (b.timer > 2.1) { delete bullets[id]; continue; }

    // collision with enemies
    if (b.ownerTag === 'player'){
      for (const eid in enemies){
        const en = enemies[eid];
        if (rectCol(b, en)){
          // hit
          safePlay(S.hit);
          addFloatingText(en.x, en.y - 10, '-' + b.damage, 'yellow', 700);
          // apply damage; if mutation pierce -> allow 1 pierce
          en.life -= b.damage>1?1:1; // coarse damage
          en.width -= b.damage * 0.5;
          en.height -= b.damage * 0.5;

          // burst spawn ability
          if (player.burstSpawn) spawnMiniFrom(en);

          // mutations: pierce
          if (mutations.find(m=>m.id==='pierce') && b.pierced < 1){
            b.pierced++;
            // continue bullet (no delete)
          } else {
            delete bullets[id];
          }

          // if enemy dead
          if (en.life <= 0 || en.width <= 8 || en.height <= 8){
            // explosion mutation
            if (mutations.find(m=>m.id==='explode')){
              // spawn small bullets outward
              for (let a=0;a<360;a+=45) spawnBullet(en, a, {speed:300, damage:2});
            }
            // if splitter -> spawn two small ones
            if (en.variant === 'splitter'){
              spawnEnemyVariant('fast'); spawnEnemyVariant('fast');
            }
            // reward
            score += 150;
            stats.kills++;
            killsSinceBoss++;
            killStreak++;
            slowTimer = Math.max(slowTimer, (killStreak >= 3) ? 800 : slowTimer);
            if (killsSinceBoss >= KILLS_FOR_BOSS){
              spawnBoss();
              killsSinceBoss = 0;
            }
            addFloatingText(en.x, en.y, 'KILL', 'lime', 900);
            delete enemies[eid];
          }
          break;
        }
      }
    } else {
      // enemy bullet may hit player
      if (rectCol(b, player)){
        player.hp -= 1;
        stats.damageTaken++;
        killStreak = 0;
        slowTimer = 0;
        shake = 6;
        addFloatingText(player.x, player.y-20, '-1 HP', 'red', 900);
        delete bullets[id];
      }
    }
  }
}

/* mini bullets from burstspawn ability */
function spawnMiniFrom(target){
  for (let a=0;a<360;a+=120) spawnBullet({x:target.x,y:target.y}, a, {speed:240, damage:2});
}

/* ----------------- BOSS ----------------- */
function spawnBoss(){
  const id = Math.random();
  const boss = { type:'boss', id, x:rand(100,WIDTH-100), y:rand(100,HEIGHT-100), width:120, height:120, life:12, color:'black', ang:0 };
  enemies[id] = boss;
  addFloatingText(boss.x, boss.y-40, 'BOSS', 'red', 1600);
}

/* ----------------- UPGRADES PICKUP ----------------- */
function pickupUpgrades(){
  for (const id in upgrades){
    const u = upgrades[id];
    if (rectCol(u, player)){
      if (u.category === 'low'){ score += 1000; safePlay(S.coin); addFloatingText(player.x, player.y-20, '+1000', 'gold', 900); }
      else if (u.category === 'atkSpeed'){ player.atkSpeed += 1; safePlay(S.powerup); addFloatingText(player.x, player.y-20, 'ATK+1', 'aqua', 900); }
      else if (u.category === 'ability'){ safePlay(S.powerup); const ab = ABILITY_POOL[Math.floor(Math.random()*ABILITY_POOL.length)]; applyAbility(ab); addFloatingText(player.x, player.y-20, ab, 'deepskyblue', 1200); }
      delete upgrades[id];
    }
  }
}

/* ----------------- ABILITIES ----------------- */
function applyAbility(name){
  player.abilities.push(name);
  switch(name){
    case 'DoubleShoot': player.doubleShoot = true; break;
    case 'DoubleDamage': player.doubleDamage = true; break;
    case 'BurstSpawn': player.burstSpawn = true; break;
    case 'SpecialMod': player.specialCooldownModifier = 0.5; break;
    case 'WideSpread': player.wideSpread = true; break;
  }
}

/* ----------------- HUD ----------------- */
function drawHUD(){
  ctx.save();
  ctx.resetTransform();
  ctx.fillStyle = '#fff';
  ctx.font = '14px Verdana';
  ctx.fillText(`HP: ${player.hp}`, 12, 20);
  ctx.fillText(`Score: ${score}`, 12, 40);
  ctx.fillText(`Kills: ${stats.kills}`, 12, 60);
  ctx.fillText(`Kill Streak: ${killStreak}`, 12, 80);
  // abilities
  ctx.fillText('Abilities:', 12, 110);
  player.abilities.forEach((a,i)=> ctx.fillText('- ' + a, 12, 130 + i*18));
  // mutations
  ctx.fillText('Mutations:', 220, 20);
  mutations.forEach((m,i)=> ctx.fillText('- ' + m.name, 220, 40 + i*18));
  // special bar
  const barX = WIDTH - 220, barY = 20;
  ctx.strokeStyle = '#888'; ctx.strokeRect(barX, barY, 200, 18);
  const specialFill = clamp(player.atkCounter / (500 * (player.specialCooldownModifier||1)), 0, 1);
  ctx.fillStyle = (specialFill>0.9?'gold':'#4af');
  ctx.fillRect(barX, barY, 200*specialFill, 18);
  ctx.fillStyle='#fff'; ctx.fillText('SPECIAL', barX + 78, barY + 13);
  ctx.restore();
}

/* ----------------- DRAW ----------------- */
function drawAll(dt){
  // optional shake
  ctx.save();
  if (shake > 0){
    const sx = (Math.random()-0.5) * shake;
    const sy = (Math.random()-0.5) * shake;
    ctx.translate(sx, sy);
  }

  // background
  ctx.fillStyle = '#222';
  ctx.fillRect(0,0,WIDTH,HEIGHT);

  // draw upgrades
  for (const id in upgrades){
    const u = upgrades[id];
    ctx.fillStyle = u.color; ctx.fillRect(u.x - u.width/2, u.y - u.height/2, u.width, u.height);
  }

  // draw enemies (with telegraph highlight)
  for (const id in enemies){
    const e = enemies[id];
    // telegraph highlight for ranged
    if (e.variant === 'ranged' && e.telegraph !== undefined && e.telegraph <= 1.6 && e.telegraph > 0.5){
      ctx.save();
      ctx.fillStyle = 'rgba(255,200,0,0.25)'; ctx.beginPath();
      ctx.arc(e.x, e.y, Math.max(20, e.width), 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }
    ctx.fillStyle = e.color; ctx.fillRect(e.x - (e.width/2), e.y - (e.height/2), e.width, e.height);
    if (e.type==='boss'){
      ctx.fillStyle='white'; ctx.fillText('BOSS', e.x-18, e.y-60);
    }
  }

  // draw bullets
  for (const id in bullets){
    const b = bullets[id];
    ctx.fillStyle = '#000'; ctx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
  }

  // player
  ctx.fillStyle = player.color; ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);

  // floating texts
  drawFloating(dt);

  ctx.restore(); // restore transform after shake
}

/* ----------------- UPDATE LOOP ----------------- */
function step(ts){
  if (lastTs === 0) lastTs = ts;
  let dt = (ts - lastTs);
  lastTs = ts;

  // slow motion
  if (slowTimer > 0){ slowFactor = 0.5; slowTimer -= dt; }
  else { slowFactor = 1; killStreak = 0; }
  const effectiveDt = dt * 0.001 * slowFactor; // seconds

  // shrink shake
  if (shake > 0) shake = Math.max(0, shake - 0.3 * dt * 0.06);

  // run only in running state
  if (state === 'running'){
    frames++;
    // spawn
    spawnTick(effectiveDt);

    // update enemy logic
    updateEnemies(effectiveDt);

    // update bullets & collisions
    updateBullets(effectiveDt);

    // pickup upgrades
    pickupUpgrades();

    // update player movement
    const pspeed = (player.hp <= 3 && mutations.find(m=>m.id==='lowhpfast')) ? 420 : 260;
    if (player.pressing.right) player.x += pspeed * effectiveDt;
    if (player.pressing.left) player.x -= pspeed * effectiveDt;
    if (player.pressing.down) player.y += pspeed * effectiveDt;
    if (player.pressing.up) player.y -= pspeed * effectiveDt;
    player.x = clamp(player.x, player.width/2, WIDTH - player.width/2);
    player.y = clamp(player.y, player.height/2, HEIGHT - player.height/2);

    // atkCounter filling and special bar
    player.atkCounter += player.atkSpeed * effectiveDt * 60;
    if (player.atkCounter > 10000) player.atkCounter = 10000;

    // time survived
    stats.timeSurvived = now() - timeStarted;

    // update HUD text (simple)
    HUD.innerHTML = '';

    // check player death
    if (player.hp <= 0){
      endRun();
    }
  }

  // draw
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  drawAll(effectiveDt);
  drawHUD();

  // decrease floatingText TTL automatically handled in drawFloating
  requestAnimationFrame(step);
}

/* ----------------- RUN CONTROL ----------------- */
function startRun(){
  // init state
  state = 'running';
  menu.style.display = 'none';
  gameOverOverlay.style.display = 'none';
  enemies = {}; bullets = {}; upgrades = {}; floatingText = []; mutations = [];
  spawnPlayer();
  score = 0; frames = 0; spawnAcc = 0; lastTs = 0;
  stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };
  shake = 0; slowTimer = 0; killStreak = 0; killsSinceBoss = 0;
  // initial spawns
  for (let i=0;i<3;i++) spawnEnemyVariant();
  timeStarted = now();
  requestAnimationFrame(step);
}

function endRun(){
  state = 'gameover';
  // present basic stats
  goStats.innerHTML = `<div>Score: ${score}</div>
    <div>Kills: ${stats.kills}</div>
    <div>Time: ${Math.round(stats.timeSurvived/1000)}s</div>
    <div class="small">Abilities: ${player.abilities.join(', ') || '—'}</div>
    <div class="small">Mutations: ${mutations.map(m=>m.name).join(', ') || '—'}</div>`;
  gameOverOverlay.style.display = 'flex';
  // stop sounds
  try { for (const k in S) { S[k].pause(); S[k].currentTime = 0; } } catch(e){}
}

/* ----------------- UTIL: spawning helper ----------------- */
function spawnEnemyVariant(kind){
  // wrapper to keep name consistent
  spawnEnemyVariantImpl(kind);
}
function spawnEnemyVariantImpl(kind){
  spawnEnemyVariantImpl = function(k){ // later calls go here; but initial wrapper above will be replaced
    // not used; placeholder
  };
}
/* define proper function now (we used another earlier); override to actual */
spawnEnemyVariantImpl = function(kind){
  const id = Math.random();
  const base = { id, type:'enemy', x:rand(40, WIDTH-40), y:rand(40, HEIGHT-40), width:rand(12,30), height:rand(12,30), vx:0, vy:0, life:1, color:'Maroon', variant:'normal' };
  if (!kind){
    const r = Math.random();
    if (r < 0.15) kind='tank';
    else if (r < 0.35) kind='fast';
    else if (r < 0.55) kind='ranged';
    else if (r < 0.7) kind='splitter';
    else kind='normal';
  }
  base.variant = kind;
  if (kind==='fast'){ base.vx = rand(-120,120); base.vy = rand(-120,120); base.life = 1; base.color='orangered'; }
  else if (kind==='tank'){ base.vx = rand(-30,30); base.vy = rand(-30,30); base.life = 4; base.color='darkred'; base.width*=1.6; base.height*=1.6; }
  else if (kind==='ranged'){ base.vx = rand(-40,40); base.vy = rand(-40,40); base.life = 2; base.color='purple'; base.telegraph = rand(0,2); }
  else if (kind==='splitter'){ base.vx = rand(-60,60); base.vy = rand(-60,60); base.life = 2; base.color='sienna'; }
  else { base.vx = rand(-50,50); base.vy = rand(-50,50); base.life = 1; base.color='maroon'; }
  enemies[id]=base;
};

/* ----------------- mini spawn boss alias ----------------- */
function spawnEnemyVariant(kind){ spawnEnemyVariantImpl(kind); }

/* ----------------- INIT / UI ----------------- */
btnStart.addEventListener('click', ()=> startRun());
btnRestart.addEventListener('click', ()=> { startRun(); gameOverOverlay.style.display='none'; });

/* start loop but wait on menu (menu visible) */
menu.style.display = 'flex';
gameOverOverlay.style.display = 'none';

/* kick off a render loop so canvas shows menu background */
requestAnimationFrame(step);

/* End of file */
</script>
</body>
</html>
