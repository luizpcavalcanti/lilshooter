<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Arena — 10 Levels, Accumulative Enemies, Mutations/Upgrades</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Verdana,Arial,Helvetica,sans-serif}
  #wrap{height:100%;display:flex;align-items:center;justify-content:center;position:relative}
  canvas{border:0.5rem outset pink;background:#222;display:block}
  #hud{position:absolute;left:12px;top:12px;color:#fff;font-size:13px;line-height:1.4}
  #menu,#gameover{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background:rgba(0,0,0,0.6)}
  button{padding:8px 12px;margin:6px;font-size:14px;cursor:pointer}
  .small{font-size:12px;color:#bbb}
  #detailPanel{position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;max-width:300px}
  .mut-list{max-height:220px;overflow:auto}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="ctx" width="900" height="800"></canvas>

  <div id="hud"></div>

  <div id="detailPanel" style="display:none">
    <div style="font-weight:bold">Detalhes (TAB para fechar)</div>
    <div id="detailUpgrades" class="small"></div>
    <div id="detailMutations" class="small mut-list" style="margin-top:6px"></div>
  </div>

  <div id="menu">
    <h2>Arena — 10 Levels</h2>
    <div class="small">WASD mover • Clique atira • Botão direito special • TAB mostra detalhes</div>
    <button id="btnStart">Iniciar Run</button>
    <div class="small">Inimigos acumulam por nível. Bosses largam mutações/upgrades.</div>
  </div>

  <div id="gameover" style="display:none">
    <h2>GAME OVER</h2>
    <div id="goStats" class="small" style="margin-bottom:8px"></div>
    <button id="btnRestart">Recomeçar</button>
  </div>
</div>

<!-- Audio files (optional, keep paths) -->
<audio id="shoot" src="./sounds/shoot.wav"></audio>
<audio id="bigshoot" src="./sounds/bigshoot.wav"></audio>
<audio id="supershoot" src="./sounds/supershoot.wav"></audio>
<audio id="powerup" src="./sounds/powerup.wav"></audio>
<audio id="coin" src="./sounds/coin.wav"></audio>
<audio id="hit" src="./sounds/hit.wav"></audio>

<script>
/* ===========================================================
   ONE-FILE: 10 LEVELS + ACCUMULATIVE ENEMY TYPES
   - Level progression
   - Enemy types unlocked cumulatively
   - Boss drops and level-up drops: mutation/upgrade
   - Upgrades stack numerically (no clutter)
   - Mutations stack via levels (single line per mutation)
   - Detail panel with TAB
   - Existing pickup types (recharge, score) unchanged
   ===========================================================*/

/* ------------------ Config / Globals ------------------ */
const canvas = document.getElementById('ctx');
const ctx = canvas.getContext('2d');
const HUD = document.getElementById('hud');
const menu = document.getElementById('menu');
const gameover = document.getElementById('gameover');
const goStats = document.getElementById('goStats');
const detailPanel = document.getElementById('detailPanel');
const detailUpgrades = document.getElementById('detailUpgrades');
const detailMutations = document.getElementById('detailMutations');
const btnStart = document.getElementById('btnStart');
const btnRestart = document.getElementById('btnRestart');

const WIDTH = canvas.width, HEIGHT = canvas.height;

/* audio helpers */
const S = {
  shoot: document.getElementById('shoot'),
  bigshoot: document.getElementById('bigshoot'),
  supershoot: document.getElementById('supershoot'),
  powerup: document.getElementById('powerup'),
  coin: document.getElementById('coin'),
  hit: document.getElementById('hit')
};
function safePlay(a){ try{ a.currentTime=0; a.play(); } catch(e){} }

/* game state */
let state = 'menu'; // menu | running | gameover
let player, enemies, bullets, pickups, floatingText;
let lastTs = 0;
let score = 0;
let level = 1;
const MAX_LEVEL = 10;

/* progression values */
let enemyPool = ['basic']; // accumulative types
let enemiesToKillThisLevel = 8; // base threshold; will scale
let killsThisLevel = 0;

/* upgrades (numeric, no clutter) */
const Upgrades = {
  moveSpeed: 0,
  fireRate: 0,
  damage: 0,
  bulletSpeed: 0,
  maxHP: 0,
  specialCharge: 0
};

/* mutations (objects with level, apply flags) */
const Mutations = {}; // key -> { level, id, name, desc }

/* mutation & upgrade pools (extendable) */
const MUTATION_POOL = [
  {id:'double_shot', name:'Double Shot', desc:'Dispara 2 projéteis.'},
  {id:'triple_shot', name:'Triple Shot', desc:'Dispara 3 projéteis.'},
  {id:'bounce', name:'Bounce', desc:'Projéteis ricocheteiam 1 vez.'},
  {id:'pierce', name:'Pierce', desc:'Projéteis atravessam 1 inimigo.'},
  {id:'burst_on_hit', name:'Burst On Hit', desc:'Ao atingir, projétil gera mini-tiros.'},
  {id:'trail', name:'Burn Trail', desc:'Projéteis deixam trilha danosa.'},
  {id:'explode_on_death', name:'Explode', desc:'Inimigo explode ao morrer.'},
  {id:'lowhp_speed', name:'LowHP Speed', desc:'Fica mais rápido com pouca vida.'},
  {id:'vampiric', name:'Vampiric', desc:'Ganha vida ao matar.'},
  {id:'charge_shot', name:'Charge Shot', desc:'Acumula para tiro mais forte.'}
];

const UPGRADE_POOL = [
  {key:'moveSpeed', name:'Move Speed'},
  {key:'fireRate', name:'Fire Rate'},
  {key:'damage', name:'Damage'},
  {key:'bulletSpeed', name:'Bullet Speed'},
  {key:'maxHP', name:'Max HP'},
  {key:'specialCharge', name:'Special Charge'}
];

/* enemy type definitions */
const ENEMY_TYPES = {
  basic: { color:'maroon', baseLife:1, baseSpeed:40 },
  fast:  { color:'orangered', baseLife:1, baseSpeed:120 },
  tank:  { color:'darkred', baseLife:4, baseSpeed:28 },
  ranged:{ color:'purple', baseLife:2, baseSpeed:30, ranged:true },
  splitter:{ color:'sienna', baseLife:2, baseSpeed:50, split:true },
  elite:{ color:'goldenrod', baseLife:3, baseSpeed:60 },
  charger:{ color:'crimson', baseLife:4, baseSpeed:90, charge:true },
  sniper:{ color:'navy', baseLife:2, baseSpeed:20, sniper:true },
  bossMinion:{ color:'black', baseLife:2, baseSpeed:40 }
};

/* visual / effects */
floatingText = [];
function addFloating(x,y,txt,color='white',ttl=900){ floatingText.push({x,y,txt,color,created:performance.now(),ttl}); }

/* stats */
let stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };

/* screen effects */
let shake = 0;
let slowTimer = 0;
let killStreak = 0;

/* spawn control */
let spawnAccumulator = 0;

/* ------------------ Utilities ------------------ */
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function now(){ return performance.now(); }
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function rectCol(a,b){ return a.x - a.width/2 < b.x + b.width/2 && a.x + a.width/2 > b.x - b.width/2 && a.y - a.height/2 < b.y + b.height/2 && a.y + a.height/2 > b.y - b.height/2; }

/* ------------------ Entities ------------------ */
function createPlayer(){
  player = {
    x: WIDTH/2, y: HEIGHT/2, width:22, height:22,
    hp: 10 + Upgrades.maxHP*2, color:'lightgreen',
    AimAngle:0, atkCounter:0, atkSpeed:1 + Upgrades.fireRate*0.15,
    pressing:{up:false,down:false,left:false,right:false},
    abilities:[], // names from mutations applied
    doubleShoot:false, tripleShot:false, wideSpread:false,
    doubleDamage:false, burstOnHit:false, specialMod:1
  };
}

function spawnEnemyOfType(type){
  const spec = ENEMY_TYPES[type] || ENEMY_TYPES.basic;
  const id = Math.random().toString(36).slice(2);
  const spawnEdge = Math.random();
  let x,y;
  if (spawnEdge < 0.25){ x=rand(0,WIDTH); y=-40; }
  else if (spawnEdge < 0.5){ x=rand(0,WIDTH); y=HEIGHT+40; }
  else if (spawnEdge < 0.75){ x=-40; y=rand(0,HEIGHT); }
  else { x=WIDTH+40; y=rand(0,HEIGHT); }
  enemies[id] = {
    id, typeName:type, x,y, width: rand(12,28) * (type==='tank'?1.6:1), height: rand(12,28)*(type==='tank'?1.6:1),
    vx:0, vy:0, life: spec.baseLife + Math.floor(level/3), color: spec.color, spec
  };
}

/* bullets & pickups */
function spawnBullet(sourceAngle, origin, opts = {}) {
  const id = Math.random().toString(36).slice(2);
  const speedBase = 650 + Upgrades.bulletSpeed*80;
  const speed = (opts.speed || speedBase);
  const damageBase = 4 + Upgrades.damage*2;
  const damage = opts.damage || damageBase;
  bullets[id] = {
    id, x: origin.x, y: origin.y, width:6, height:6,
    xs: Math.cos(sourceAngle*Math.PI/180)*speed, ys: Math.sin(sourceAngle*Math.PI/180)*speed,
    timer:0, damage, owner:'player', bounces: (Mutations['bounce']?Mutations['bounce'].level:0), pierced:0
  };
}

function spawnPickup(type, x,y){
  const id = Math.random().toString(36).slice(2);
  pickups[id] = { id, type, x:x||rand(40,WIDTH-40), y:y||rand(40,HEIGHT-40), width:14, height:14 };
}

/* ------------------ Level / Progression ------------------ */
function initLevelSystem(){
  level = 1;
  enemyPool = ['basic'];
  enemiesToKillThisLevel = 8;
  killsThisLevel = 0;
}

function advanceLevel(){
  if (level >= MAX_LEVEL) return;
  level++;
  // unlock type by level (accumulative)
  const unlocks = {
    2: 'fast',
    3: 'tank',
    4: 'ranged',
    5: 'splitter',
    6: 'elite',
    7: 'charger',
    8: 'sniper',
    9: 'bossMinion',
    10:'elite' // final intensify
  };
  const t = unlocks[level];
  if (t && !enemyPool.includes(t)) enemyPool.push(t);

  // increase how many kills needed next level
  enemiesToKillThisLevel = Math.round(8 + level * 2.5);

  // give guaranteed random mutation or upgrade when leveling up
  giveLevelReward();

  // small message
  addFloating(WIDTH/2, HEIGHT/2 - 30, 'LEVEL UP → ' + level, 'yellow', 1400);
}

/* reward logic: boss drops handled separately; this is for level up */
function giveLevelReward(){
  // choose mutation or upgrade randomly (70% mutation, 30% upgrade)
  if (Math.random() < 0.7){
    grantRandomMutation();
  } else {
    grantRandomUpgrade();
  }
}

/* ------------------ Mutations & Upgrades logic ------------------ */
function grantRandomMutation(){
  // choose mutation not present preferably
  const notHave = MUTATION_POOL.filter(m => !Mutations[m.id]);
  const pick = (notHave.length ? notHave[Math.floor(Math.random()*notHave.length)] : MUTATION_POOL[Math.floor(Math.random()*MUTATION_POOL.length)]);
  applyMutation(pick);
}

function applyMutation(m){
  if (!Mutations[m.id]){
    Mutations[m.id] = { level:1, id:m.id, name:m.name, desc:m.desc };
    addFloating(player.x, player.y - 24, 'MUTATION: ' + m.name, 'cyan', 1200);
  } else {
    Mutations[m.id].level++;
    addFloating(player.x, player.y - 24, 'MUTATION UP: ' + m.name + ' +' + (Mutations[m.id].level-1), 'lightgreen', 1000);
  }
  // apply instant flags for certain mutations
  applyMutationEffects();
}

function applyMutationEffects(){
  // clear flags
  player.doubleShoot = false; player.tripleShot = false; player.burstOnHit = false; player.specialMod = 1;
  // reapply from mutation table
  if (Mutations['double_shot']) player.doubleShoot = true;
  if (Mutations['triple_shot']) player.tripleShot = true;
  if (Mutations['burst_on_hit']) player.burstOnHit = true;
  if (Mutations['charge_shot']) player.chargeShot = true;
  if (Mutations['double_shot'] && Mutations['triple_shot']) player.doubleShoot = true; // both -> double stays
  if (Mutations['pierce']) player.pierce = true;
  if (Mutations['double_shot'] && Mutations['double_shot'].level>1) player.doubleDamage = true;
  // special mod scaling
  if (Mutations['charge_shot']) { player.specialMod = Math.max(0.5, 1 - 0.1*(Mutations['charge_shot'].level-1)); }
  // vampiric handled at kill time
}

/* upgrades */
function grantRandomUpgrade(){
  // choose random upgrade key
  const pick = UPGRADE_POOL[Math.floor(Math.random()*UPGRADE_POOL.length)];
  Upgrades[pick.key] = (Upgrades[pick.key]||0) + 1;
  addFloating(player.x, player.y - 24, 'UPGRADE: ' + pick.name + ' Lvl ' + Upgrades[pick.key], 'aqua', 1000);
  // apply upgrade immediate effects where needed
  applyUpgradeEffects();
}

function applyUpgradeEffects(){
  // update player attrs depending on upgrades
  if (player){
    player.atkSpeed = 1 + (Upgrades.fireRate * 0.15);
    // max HP buff applied at createPlayer time on new run; we just update hp if desired
    player.hp = Math.min(player.hp, 10 + Upgrades.maxHP*2); // don't increase current hp automatically
  }
}

/* ------------------ Boss logic ------------------ */
function spawnBossForLevel(l){
  // bigger boss on certain levels
  const id = 'boss_' + Math.random().toString(36).slice(2);
  const bsize = 100 + (l-1)*8;
  enemies[id] = {
    id, typeName:'boss', x:WIDTH/2, y: -bsize, width:bsize, height:bsize, life: 8 + l*2, color:'black', boss:true, ang:0
  };
  addFloating(WIDTH/2, 80, 'BOSS: Level ' + l, 'red', 1600);
}

/* ------------------ Spawn & Update Loop ------------------ */
function spawnTick(dt){
  spawnAccumulator += dt;
  const baseInterval = Math.max(0.5, 2.5 - level*0.15);
  while (spawnAccumulator > baseInterval){
    spawnAccumulator -= baseInterval;
    // choose type from enemyPool (accumulative)
    const t = enemyPool[Math.floor(Math.random()*enemyPool.length)];
    spawnEnemyOfType(t);
  }
  // occasional pickup: score/recharge unchanged behavior
  if (Math.random() < 0.008 + level*0.001) spawnPickup('score');
  if (Math.random() < 0.006 + level*0.0008) spawnPickup('recharge');
}

/* enemy behavior */
function updateEnemies(dt){
  for (const id in enemies){
    const e = enemies[id];
    if (e.boss){
      // boss slow entrance then move
      if (e.y < 120) e.y += 30 * dt;
      else {
        e.ang += dt * 0.5;
        e.x = WIDTH/2 + Math.cos(e.ang) * 120;
        e.y = 140 + Math.sin(e.ang) * 20;
        // boss shoots occasionally
        if (!e._lastShot || now()-e._lastShot > 1500){
          e._lastShot = now();
          // shoot several projectiles outward
          for (let a=0;a<360;a+=30) {
            spawnEnemyBullet(e.x, e.y, a);
          }
        }
      }
    } else {
      // simple AI: move toward player
      const angle = Math.atan2(player.y - e.y, player.x - e.x);
      const spec = e.spec || ENEMY_TYPES[e.typeName] || ENEMY_TYPES.basic;
      let speed = (spec.baseSpeed || 40);
      // scale with level and upgrades
      speed *= (1 + level*0.04);
      e.x += Math.cos(angle) * speed * dt;
      e.y += Math.sin(angle) * speed * dt;
      // ranged specific: telegraph (visual) then shoot
      if (spec.ranged){
        e._tele = (e._tele||0) - dt;
        if (e._tele <= 0){
          e._tele = 2 + Math.random()*2;
          // shoot toward player
          const ang = Math.atan2(player.y - e.y, player.x - e.x) * 180/Math.PI;
          spawnEnemyBullet(e.x, e.y, ang);
        }
      }
    }
  }
}

/* bullets update */
function updateBullets(dt){
  for (const id in bullets){
    const b = bullets[id];
    b.timer += dt;
    b.x += b.xs * dt;
    b.y += b.ys * dt;

    // trail mutation visual
    if (Mutations['trail']) { if (Math.random() < 0.02) addFloating(b.x, b.y, '.', 'orange', 300); }

    // boundary check
    if (b.x < -50 || b.x > WIDTH+50 || b.y < -50 || b.y > HEIGHT+50){ delete bullets[id]; continue; }

    // player bullets hit enemies
    if (b.owner === 'player'){
      for (const eid in enemies){
        const en = enemies[eid];
        if (rectCol(b, en)){
          // apply damage
          en.life -= Math.round(b.damage/4) || 1;
          en.width -= b.damage * 0.2;
          en.height -= b.damage * 0.2;
          addFloating(en.x, en.y-10, '-' + Math.round(b.damage), 'yellow', 700);

          // burst on hit mutation
          if (Mutations['burst_on_hit']) {
            const lvl = Mutations['burst_on_hit'].level;
            for (let a=0;a<360;a+=120){
              spawnBullet(a + rand(-10,10), {x:en.x, y:en.y}, {speed:240, damage:2 + lvl});
            }
          }

          // piercing mutation: allow one pierce per level
          if (Mutations['pierce']){
            b.pierced = (b.pierced||0) + 1;
            const maxPierce = Mutations['pierce'].level;
            if (b.pierced <= maxPierce){ /* let pass */ } else { delete bullets[id]; }
          } else {
            delete bullets[id];
          }

          // enemy death
          if (en.life <= 0 || en.width <= 8 || en.height <= 8){
            // explode mutation
            if (Mutations['explode_on_death']) {
              const lvl = Mutations['explode_on_death'].level;
              for (let a=0;a<360;a+=45) spawnBullet(a + rand(-8,8), {x:en.x, y:en.y}, {speed:320, damage:2 + lvl});
            }
            // splitter spawn
            if (en.typeName === 'splitter'){
              spawnEnemyOfType('fast'); spawnEnemyOfType('fast');
            }
            // vampiric
            if (Mutations['vampiric']) {
              const gain = Mutations['vampiric'].level;
              player.hp = Math.min(10 + Upgrades.maxHP*2, player.hp + gain);
            }
            // count kill
            delete enemies[eid];
            stats.kills++; killsThisLevel++; score += 150;
            killStreak++;
            // slow on streak
            if (killStreak >= 3) slowTimer = 800;
            // boss spawn trigger
            if (killsThisLevel >= enemiesToKillThisLevel){
              // advance level
              killsThisLevel = 0;
              advanceLevel();
              // on some levels spawn boss
              if ([4,6,8,10].includes(level)) spawnBossForLevel(level);
            }
          }
          break;
        }
      }
    } else {
      // enemy bullet hits player
      if (rectCol(b, player)){
        player.hp -= 1;
        stats.damageTaken++;
        killStreak = 0; slowTimer = 0; shake = 6;
        addFloating(player.x, player.y-18, '-1 HP', 'red', 900);
        delete bullets[id];
      }
    }
  }
}

/* enemy bullets */
function spawnEnemyBullet(x,y,angleDeg){
  const id = Math.random().toString(36).slice(2);
  const speed = 300;
  bullets[id] = { id, x, y, width:6, height:6, xs:Math.cos(angleDeg*Math.PI/180)*speed, ys:Math.sin(angleDeg*Math.PI/180)*speed, timer:0, damage:2, owner:'enemy' };
}

/* pickups: 'score' and 'recharge' unchanged behavior; 'reward' used for level/boss drops */
function pickupCheck(){
  for (const id in pickups){
    const p = pickups[id];
    if (rectCol(p, player)){
      if (p.type === 'score'){ score += 1000; safePlay(S.coin); addFloating(player.x, player.y-20, '+1000', 'gold', 900); }
      else if (p.type === 'recharge'){ player.atkCounter += 150; safePlay(S.powerup); addFloating(player.x, player.y-20, 'RECHARGE', 'aqua', 900); }
      else if (p.type === 'reward'){
        // reward can be mutation or upgrade guaranteed (boss/level)
        if (Math.random() < 0.7) grantRandomMutation(); else grantRandomUpgrade();
      }
      delete pickups[id];
    }
  }
}

/* ------------------ Reward functions ------------------ */
function spawnRewardDrop(x,y){
  spawnPickup('reward', x,y);
}
function spawnPickup(type, x,y){
  const id = Math.random().toString(36).slice(2);
  pickups[id] = { id, type, x:x||rand(60,WIDTH-60), y:y||rand(60,HEIGHT-60), width:14, height:14 };
}

/* grant random upgrade */
function grantRandomUpgrade(){
  const pick = UPGRADE_POOL[Math.floor(Math.random()*UPGRADE_POOL.length)];
  Upgrades[pick.key] = (Upgrades[pick.key]||0) + 1;
  applyUpgradeEffects();
  addFloating(player.x, player.y-20, 'UPGRADE: ' + pick.name + ' Lvl ' + Upgrades[pick.key], 'aqua', 1200);
}

/* ------------------ Apply upgrades effects ------------------ */
function applyUpgradeEffects(){
  if (player){
    player.atkSpeed = 1 + (Upgrades.fireRate * 0.18);
    player.maxHP = 10 + (Upgrades.maxHP * 2);
    // do not forcibly refill HP; optional
  }
}

/* ------------------ Mutations application after changes ------------------ */
function applyAllMutations(){
  // reset flags
  if (!player) return;
  player.doubleShoot = !!Mutations['double_shot'];
  player.tripleShot = !!Mutations['triple_shot'];
  player.burstOnHit = !!Mutations['burst_on_hit'];
  player.chargeShot = !!Mutations['charge_shot'];
  player.specialMod = 1;
  if (Mutations['charge_shot']) player.specialMod = Math.max(0.5, 1 - 0.08*(Mutations['charge_shot'].level-1));
  player.pierce = !!Mutations['pierce'];
  player.doubleDamage = Mutations['double_shot'] && Mutations['double_shot'].level>1;
}

/* ------------------ Screen draw ------------------ */
function drawAll(dt){
  // shake
  ctx.save();
  if (shake > 0) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);

  // background
  ctx.fillStyle = '#222'; ctx.fillRect(0,0,WIDTH,HEIGHT);

  // pickups
  for (const id in pickups){
    const p = pickups[id];
    ctx.fillStyle = (p.type==='score')?'gold':(p.type==='recharge')?'aqua':'deepskyblue';
    ctx.fillRect(p.x - p.width/2, p.y - p.height/2, p.width, p.height);
  }

  // enemies
  for (const id in enemies){
    const e = enemies[id];
    // if ranged telegraph: small circle
    if (e.spec && e.spec.ranged && e._tele && e._tele < 1.6 && e._tele > 0.5){
      ctx.fillStyle = 'rgba(255,200,0,0.2)';
      ctx.beginPath(); ctx.arc(e.x, e.y, Math.max(20, e.width), 0, Math.PI*2); ctx.fill();
    }
    ctx.fillStyle = e.color || 'maroon';
    ctx.fillRect(e.x - e.width/2, e.y - e.height/2, e.width, e.height);
    if (e.boss){
      ctx.fillStyle='white'; ctx.font='16px Verdana'; ctx.fillText('BOSS', e.x - 24, e.y - e.height/2 - 8);
    }
  }

  // bullets
  for (const id in bullets){
    const b = bullets[id];
    ctx.fillStyle = '#000'; ctx.fillRect(b.x - b.width/2, b.y - b.height/2, b.width, b.height);
  }

  // player
  ctx.fillStyle = player.color; ctx.fillRect(player.x - player.width/2, player.y - player.height/2, player.width, player.height);

  // floating text
  const nowt = now();
  for (let i=floatingText.length-1;i>=0;i--){
    const f = floatingText[i];
    const age = nowt - f.created;
    if (age > f.ttl){ floatingText.splice(i,1); continue; }
    ctx.globalAlpha = clamp(1 - age/f.ttl, 0,1);
    ctx.fillStyle = f.color; ctx.font='14px Verdana'; ctx.fillText(f.txt, f.x, f.y - (age/30));
    ctx.globalAlpha = 1;
  }

  ctx.restore();
}

/* draw HUD and compact info (no clutter) */
function drawHUD(){
  HUD.innerHTML = `
    LVL: ${level} / ${MAX_LEVEL}&nbsp;&nbsp; SCORE: ${score}<br>
    HP: ${player.hp} &nbsp;&nbsp; KILLS-LVL: ${killsThisLevel}/${enemiesToKillThisLevel} &nbsp;&nbsp; KILLS-TOTAL: ${stats.kills}<br>
    Abilities: ${Object.keys(Mutations).length} &nbsp;&nbsp; Upgrades: ${Object.values(Upgrades).reduce((a,b)=>a+(b||0),0)}
    <div class="small">Press TAB to show details</div>
  `;
  // detail panel content build when visible
  if (detailPanel.style.display !== 'none'){
    // Upgrades
    let upHTML = '<b>Upgrades</b><br>';
    UPGRADE_POOL.forEach(u=> upHTML += `${u.name}: Lvl ${Upgrades[u.key]||0}<br>`);
    detailUpgrades.innerHTML = upHTML;
    // Mutations
    let muHTML = '<b>Mutations</b><br>';
    for (const k in Mutations){
      const m = Mutations[k];
      muHTML += `${m.name} (Lvl ${m.level}) — ${m.desc}<br>`;
    }
    if (!Object.keys(Mutations).length) muHTML += 'Nenhuma<br>';
    detailMutations.innerHTML = muHTML;
  }
}

/* ------------------ Game loop ------------------ */
function step(ts){
  if (!lastTs) lastTs = ts;
  let dtMs = ts - lastTs; lastTs = ts;
  if (dtMs > 100) dtMs = 100; // clamp
  // slow motion
  if (slowTimer > 0){ slowTimer -= dtMs; dtMs *= 0.45; } else { slowTimer = 0; }
  const dt = dtMs * 0.001;

  // update
  if (state === 'running'){
    spawnTick(dt);
    updateEnemies(dt);
    updateBullets(dt);
    pickupCheck();
    // movement
    const baseSpeed = 260 + Upgrades.moveSpeed*12;
    const speed = (player.hp <= 3 && Mutations['lowhp_speed']) ? baseSpeed*1.4 : baseSpeed;
    if (player.pressing.right) player.x += speed * dt;
    if (player.pressing.left) player.x -= speed * dt;
    if (player.pressing.down) player.y += speed * dt;
    if (player.pressing.up) player.y -= speed * dt;
    player.x = clamp(player.x, player.width/2, WIDTH - player.width/2);
    player.y = clamp(player.y, player.height/2, HEIGHT - player.height/2);
    // atkCounter fill (special)
    player.atkCounter += player.atkSpeed * dt * 60 * (1 + (Upgrades.specialCharge*0.05));
    if (player.atkCounter > 10000) player.atkCounter = 10000;
    // apply mutation flags
    applyAllMutations();
    // decrease shake
    if (shake > 0) shake = Math.max(0, shake - 0.3 * (dtMs/16));
    // update stats time
    stats.timeSurvived = now() - startTime;
    // check death
    if (player.hp <= 0){ finishRun(); }
  }

  // render
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  drawAll(dt);
  drawHUD();

  requestAnimationFrame(step);
}

/* ------------------ Player input & shooting ------------------ */
canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  player.AimAngle = Math.atan2(my - player.y, mx - player.x) * 180 / Math.PI;
});
canvas.addEventListener('click', ()=>{
  if (state !== 'running') return;
  if (player.atkCounter > 50){
    safePlay(S.shoot);
    player.atkCounter -= 25;
    stats.shots++;
    // shooting variants from mutations/upgrades
    if (Mutations['triple_shot']) {
      spawnBullet(player.AimAngle - 12, player); spawnBullet(player.AimAngle, player); spawnBullet(player.AimAngle + 12, player);
    } else if (Mutations['double_shot']){
      spawnBullet(player.AimAngle - 6, player); spawnBullet(player.AimAngle + 6, player);
    } else {
      spawnBullet(player.AimAngle, player);
    }
  }
});
canvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
  if (state !== 'running') return;
  const required = 500 * (player.specialMod || 1);
  if (player.atkCounter >= required){
    safePlay(S.supershoot);
    for (let a=0;a<360;a+=9) spawnBullet(a, player);
    player.atkCounter = 0;
    shake = 10;
    addFloating(player.x, player.y-20, 'SPECIAL!', 'yellow', 1200);
    return;
  }
  if (player.atkCounter >= 50){
    safePlay(S.bigshoot);
    player.atkCounter -= 50;
    for (let off=-15; off<=15; off+=10) spawnBullet(player.AimAngle + off, player);
  }
});

document.addEventListener('keydown', e=>{
  if (!player) return;
  if (e.key === 'w' || e.key === 'W') player.pressing.up = true;
  if (e.key === 's' || e.key === 'S') player.pressing.down = true;
  if (e.key === 'a' || e.key === 'A') player.pressing.left = true;
  if (e.key === 'd' || e.key === 'D') player.pressing.right = true;
  if (e.key === 'Tab'){ e.preventDefault(); toggleDetails(); }
});
document.addEventListener('keyup', e=>{
  if (!player) return;
  if (e.key === 'w' || e.key === 'W') player.pressing.up = false;
  if (e.key === 's' || e.key === 'S') player.pressing.down = false;
  if (e.key === 'a' || e.key === 'A') player.pressing.left = false;
  if (e.key === 'd' || e.key === 'D') player.pressing.right = false;
});

/* toggle detail panel */
function toggleDetails(){
  detailPanel.style.display = (detailPanel.style.display === 'none') ? 'block' : 'none';
}

/* ------------------ Run control ------------------ */
let startTime = 0;
btnStart.addEventListener('click', ()=>{ startRun(); });
btnRestart.addEventListener('click', ()=>{ startRun(); gameover.style.display='none'; });

function startRun(){
  // reset core state
  state = 'running';
  menu.style.display = 'none';
  gameover.style.display = 'none';
  enemies = {}; bullets = {}; pickups = {}; floatingText = []; Mutations = Mutations || {};
  // clear upgrades & mutations? keep across runs? user requested no save system, so we reset per run
  for (const k in Upgrades) Upgrades[k]=0;
  for (const k in Mutations) delete Mutations[k];
  initLevelSystem();
  applyUpgradeEffects();
  createPlayer();
  score = 0; stats = { shots:0, hits:0, kills:0, damageTaken:0, timeSurvived:0 };
  spawnAccumulator = 0; killsThisLevel = 0;
  // initial enemies
  for (let i=0;i<3;i++) spawnEnemyOfType('basic');
  startTime = now();
  lastTs = 0;
  requestAnimationFrame(step);
}

/* finish run */
function finishRun(){
  state = 'gameover';
  gameover.style.display = 'flex';
  goStats.innerHTML = `Score: ${score}<br>Kills: ${stats.kills}<br>Time: ${Math.round(stats.timeSurvived/1000)}s<br>Level reached: ${level}<br>
    <div class="small">Upgrades: ${Object.values(Upgrades).reduce((a,b)=>a+(b||0),0)} • Mutations: ${Object.keys(Mutations).length}</div>`;
}

/* ------------------ Initial UI ------------------ */
menu.style.display='flex';
gameover.style.display='none';
detailPanel.style.display='none';

/* ensure player object exists for menu preview */
createPlayer();
requestAnimationFrame(step);

</script>
</body>
</html>
